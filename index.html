<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simulazione Test Soccorritore (PDF)</title>

<!-- Stili semplici e leggibili -->
<style>
  :root{ --bg:#f6f8fb; --card:#fff; --accent:#0b77f4; --ok:#1e9e4a; --ko:#d32f2f; }
  html,body{ height:100%; margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial; background:var(--bg); color:#111; }
  .wrap{ max-width:980px; margin:28px auto; padding:20px; }
  .card{ background:var(--card); border-radius:10px; box-shadow:0 6px 18px rgba(15,20,30,0.08); padding:18px; margin-bottom:14px; }
  h1{ margin:0 0 6px 0; font-size:20px; }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  input[type=password], textarea{ width:100%; padding:10px; border-radius:8px; border:1px solid #ddd; font-size:15px; box-sizing:border-box; }
  button{ background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:8px; cursor:pointer; font-weight:600; }
  button.secondary{ background:#f0f0f0; color:#111; }
  .hidden{ display:none; }
  #answers{ margin-top:12px; display:grid; gap:8px; grid-template-columns:1fr; }
  .ans-btn{ padding:12px; text-align:left; border-radius:8px; border:1px solid #e5e7eb; background:#fff; cursor:pointer; font-size:15px; }
  .ans-btn[disabled]{ opacity:.6; cursor:not-allowed; }
  #feedback{ margin-top:12px; font-weight:700; }
  pre#debug{ background:#0f1724; color:#d1d5db; padding:12px; border-radius:8px; max-height:220px; overflow:auto; font-size:13px; white-space:pre-wrap; }
  .small { font-size:13px; color:#555; }
  .correct { color:var(--ok); }
  .wrong { color:var(--ko); }
  .meta { display:flex; gap:8px; align-items:center; margin-top:8px; color:#666; font-size:13px; }
  .badge{ background:#eef6ff; color:var(--accent); padding:4px 8px; border-radius:999px; font-weight:700; }
  code{ background:#f3f4f6; padding:2px 6px; border-radius:6px; }
</style>

<!-- Carico pdf.js da un CDN (worker configurato lato client) -->
<script src="https://unpkg.com/pdfjs-dist@3.8.162/build/pdf.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Accesso test</h1>
    <div class="small">Inserisci il codice per avviare il test (codice: <code>13112005</code>)</div>
    <div style="margin-top:12px;" class="row">
      <input id="accessCode" type="password" placeholder="Codice di accesso">
      <button id="btnLogin">Accedi</button>
      <button id="btnDemo" class="secondary">Demo (salta login)</button>
    </div>
    <div id="loginMsg" class="small" style="color:#b00; margin-top:8px;"></div>
  </div>

  <div id="quizCard" class="card hidden">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div>
        <h1 id="questionTitle">Domanda</h1>
        <div class="small" id="qInfo">0 / 0</div>
      </div>
      <div>
        <div class="badge" id="scoreBadge">0/0</div>
      </div>
    </div>

    <div id="answers" style="margin-top:12px;"></div>

    <div id="feedback" class="small"></div>

    <div style="margin-top:12px;" class="row">
      <button id="nextBtn" class="hidden">Prossima domanda</button>
      <button id="endBtn" class="secondary hidden">Termina test</button>
    </div>

    <div class="meta">
      <div id="elapsed">Tempo: 0s</div>
      <div id="lastAction">Ultima azione: -</div>
    </div>
  </div>

  <div id="fallbackCard" class="card hidden">
    <h1>Fallback: incolla il testo (se il PDF non viene caricato)</h1>
    <div class="small">Se il fetch del PDF fallisce, incolla qui il contenuto estratto (ogni domanda inizia con <code>-</code>, risposte A-D; la corretta con <code>*</code> davanti).</div>
    <textarea id="manualInput" rows="8" placeholder="Incolla qui il testo..."></textarea>
    <div style="margin-top:10px;" class="row">
      <button id="useManual">Usa testo incollato</button>
      <button id="clearManual" class="secondary">Pulisci</button>
    </div>
  </div>

  <div class="card">
    <h1>Debug</h1>
    <div class="small">Log visibile per capire cosa succede (utile per debug).</div>
    <pre id="debug">Pronto.</pre>
  </div>
</div>

<script>
/*
  index.html aggiornato per leggere domandetest3.pdf (PDF) e parsare il formato:
    - ogni domanda inizia con '-'
    - risposte A/B/C/D su righe successive
    - la risposta corretta ha un '*' davanti (es. "*A Risposta..." oppure "A *Risposta" o "A Risposta *")
  Usa pdf.js (caricato sopra) per estrarre il testo lato client.
  Commenti ed error handling per essere robusti.
*/

/* -------- CONFIG -------- */
const ACCESS_CODE = "13112005";
const PDF_FILE = "domandetest3.pdf";          // file pdf che hai caricato
const TXT_FALLBACKS = ["domandetest2","domandetest2.txt"]; // fallback di testo (se vuoi)

/* -------- stato applicazione -------- */
let questions = [];     // array domande strutturate { text, answers: [{label,text,correct}], id }
let order = [];         // ordine random delle domande
let idx = 0;            // indice corrente
let correctCount = 0;
let totalAnswered = 0;
let startTime = null;
let timerInterval = null;

/* -------- helper debug UI -------- */
function debugLog(...args){
  const el = document.getElementById('debug');
  const t = new Date().toISOString().slice(11,19);
  el.textContent = `${t} › ${args.map(a=> (typeof a==='object'? JSON.stringify(a,null,2): a)).join(' ')}\n` + el.textContent;
  document.getElementById('lastAction').textContent = 'Ultima azione: ' + (args[0] || '-');
}

/* -------- Login e pulsanti -------- */
document.getElementById('btnLogin').addEventListener('click', () => {
  const code = document.getElementById('accessCode').value.trim();
  if(code === ACCESS_CODE){
    document.getElementById('loginMsg').textContent = '';
    startApp();
  } else {
    document.getElementById('loginMsg').textContent = 'Codice errato.';
    debugLog('Login fallito', code);
  }
});
document.getElementById('btnDemo').addEventListener('click', () => {
  debugLog('Demo: salto login');
  startApp();
});

/* -------- Avvio applicazione: prova a leggere PDF -> se no fallback testo -------- */
async function startApp(){
  document.getElementById('quizCard').classList.remove('hidden');
  document.getElementById('fallbackCard').classList.add('hidden');
  document.getElementById('debug').textContent = ''; // reset debug
  debugLog('Avvio: provo a caricare PDF', PDF_FILE);

  // config del worker di pdf.js (usa lo stesso CDN)
  if(window.pdfjsLib){
    // workerSrc necessario per alcune build
    pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@3.8.162/build/pdf.worker.min.js";
  } else {
    debugLog('pdfjs non disponibile sul client. Assicurati che lo script sia caricato.');
    // fallback a textarea
    document.getElementById('fallbackCard').classList.remove('hidden');
    return;
  }

  // prova a fetchare il PDF (arrayBuffer)
  try {
    const resp = await fetch(PDF_FILE);
    if(!resp.ok) throw new Error('PDF non trovato: ' + resp.status);
    const arrayBuffer = await resp.arrayBuffer();
    debugLog('PDF scaricato, bytes:', arrayBuffer.byteLength);
    const text = await extractTextFromPDF(arrayBuffer);
    debugLog('Testo estratto dal PDF (prima parte):', text.slice(0,300));
    parseQuestionsFromPlainText(text);
  } catch(err){
    debugLog('Errore caricamento PDF:', err.message || err);
    // prova fallback a file txt (se presenti)
    for(const f of TXT_FALLBACKS){
      try {
        debugLog('Provo a caricare fallback testo:', f);
        const r = await fetch(f);
        if(!r.ok){ debugLog('Fallback non trovato:', f, 'status', r.status); continue; }
        const t = await r.text();
        debugLog('Fallback testo caricato:', f, 'bytes', t.length);
        parseQuestionsFromPlainText(t);
        return;
      } catch(e){
        debugLog('Errore fallback fetch', f, e.message || e);
      }
    }
    // abilita fallback manuale (textarea)
    debugLog('Nessun file caricato -> attivo textarea fallback');
    document.getElementById('fallbackCard').classList.remove('hidden');
    return;
  }

  // dopo parsing controlliamo se ci sono domande valide
  if(questions.length === 0){
    debugLog('Parsing non ha trovato domande valide -> fallback abilitato');
    document.getElementById('fallbackCard').classList.remove('hidden');
    return;
  }

  // setup test
  shuffleOrder();
  idx = 0; correctCount = 0; totalAnswered = 0;
  startTime = Date.now();
  startTimer();
  showQuestion();
}

/* -------- Estrazione testo dal PDF usando pdf.js -------- */
async function extractTextFromPDF(arrayBuffer){
  // carica documento
  const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
  const pdf = await loadingTask.promise;
  debugLog('PDF caricato, pagine:', pdf.numPages);
  let fullText = "";
  // estrai pagina per pagina
  for(let p=1; p<=pdf.numPages; p++){
    try {
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();
      // content.items è un array di oggetti con str
      const strings = content.items.map(i => i.str);
      const pageText = strings.join(' ');
      // Aggiungiamo un separatore di pagina per sicurezza
      fullText += pageText + '\n\n';
    } catch(e){
      debugLog('Errore estrazione pagina', p, e.message || e);
    }
  }
  // ritorna testo normalizzato
  return normalizeExtractedText(fullText);
}

/* -------- Normalizza il testo estratto (compatto ma con \n per separazioni) -------- */
function normalizeExtractedText(t){
  // PDF text extraction può unire frasi; cerco di reinserire break dove ci sono '- ' iniziali e dove ci sono lettere A-D seguite da spazio.
  // Sostituisco sequenze multiple di spazi con uno spazio
  let s = t.replace(/\u00A0/g,' ').replace(/\s+/g,' ');
  // metto a capo prima di trattini che indicano nuove domande, se presenti come " - " oppure "- "
  s = s.replace(/ - /g, '\n- ');
  s = s.replace(/\s-\s/g, '\n- ');
  // metto a capo prima delle opzioni " A " " B " ecc. ma solo se appaiono con lettera maiuscola seguita da spazio e una parola (evito separazioni false)
  s = s.replace(/\s([A-D])\s+/g, '\n$1 ');
  // metto a capo anche dove compare "*A" (asterisco+lettera)
  s = s.replace(/\*(?=[A-D]\s)/g, '\n*');
  // Ora split in righe su '\n' e risettiamo una linea per ogni elemento, poi join con \n
  const lines = s.split('\n').map(l => l.trim()).filter(l=>l.length>0);
  return lines.join('\n');
}

/* -------- Parsing del testo (formato con '-' domanda e risposte A-D) -------- */
function parseQuestionsFromPlainText(text){
  questions = [];
  // separo in righe
  const rawLines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l.length>0);
  debugLog('Numero righe estratte:', rawLines.length);

  let current = null;
  let idCounter = 0;

  for(let i=0;i<rawLines.length;i++){
    const line = rawLines[i];
    // se la riga inizia con '-' => nuova domanda
    if(line.startsWith('-')){
      // chiudi eventuale domanda precedente
      current = { text: line.replace(/^\-\s*/,'').trim(), answers: [], id: ++idCounter };
      questions.push(current);
      continue;
    }
    // altrimenti cerco se è una risposta: può essere "*A ..." oppure "A ..." o "A *..." ecc.
    const answerMatch = line.match(/^\*?\s*([A-D])\s*[\)\.\-]?\s*(.*)$/i); // cattura *A, A) A. A-
    if(answerMatch){
      const rawLabel = answerMatch[1].toUpperCase();
      let rawText = answerMatch[2].trim();
      // determina se c'era un asterisco davanti nella riga
      const leadingStar = /^\*\s*/.test(line);
      // oppure se l'asterisco è dentro il testo (es. "Risposta *" o "Risposta*")
      const trailingStar = /\*\s*$/.test(rawText);
      // se trailingStar rimuovilo
      if(trailingStar) rawText = rawText.replace(/\*\s*$/,'').trim();
      // se rawText inizia con '*' (es. "*Risposta")
      if(/^\*\s*/.test(rawText)) { rawText = rawText.replace(/^\*\s*/,'').trim(); }

      const correct = leadingStar || trailingStar;
      // se non c'è una domanda corrente, creane una placeholder (evitiamo crash)
      if(!current){
        current = { text: "(Domanda non trovata — generata automaticamente)", answers: [], id: ++idCounter };
        questions.push(current);
        debugLog('Trovata risposta senza domanda. Generata domanda placeholder alla riga', i+1);
      }
      current.answers.push({ label: rawLabel, text: rawText, correct: !!correct });
      continue;
    }

    // Se la riga non è né domanda né risposta, può essere continuazione della domanda (testo su più righe)
    if(current && current.answers.length === 0){
      // appendiamo alla domanda corrente (se ancora non abbiamo risposte)
      current.text += ' ' + line;
    } else if(current && current.answers.length > 0){
      // potrebbe essere testo continuativo della precedente risposta: aggiungiamolo all'ultima risposta
      const last = current.answers[current.answers.length-1];
      if(last){
        last.text += ' ' + line;
      }
    } else {
      // linea ignota: la consideriamo come domanda nuova
      current = { text: line.trim(), answers: [], id: ++idCounter };
      questions.push(current);
    }
  }

  // Pulizia: rimuovo domande che non hanno almeno 2 risposte valide (preferisco >=3/4)
  const before = questions.length;
  questions = questions.filter(q => q.answers && q.answers.length >= 2);
  debugLog(`Parsing completato. Domande trovate: ${before} -> valide: ${questions.length}`);
  debugLog('Prime 5 domande (anteprima):', questions.slice(0,5).map(q=>({id:q.id, text:q.text.slice(0,120), answers:q.answers})));

  // se ci sono domande valide, continua con test
  if(questions.length > 0){
    shuffleOrder();
    idx = 0; correctCount = 0; totalAnswered = 0;
    startTime = Date.now(); startTimer();
    showQuestion();
  }
}

/* -------- misc helpers: shuffle -------- */
function shuffleArray(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i], a[j]] = [a[j], a[i]];
  }
}

/* -------- ordina le domande casualmente -------- */
function shuffleOrder(){
  order = questions.map((_,i)=>i);
  shuffleArray(order);
  debugLog('Ordine domande mescolato, tot:', order.length);
}

/* -------- mostra domanda corrente -------- */
function showQuestion(){
  if(!questions || questions.length === 0){
    document.getElementById('questionTitle').textContent = 'Nessuna domanda disponibile';
    document.getElementById('answers').innerHTML = '';
    debugLog('showQuestion: nessuna domanda');
    return;
  }
  if(idx >= order.length){
    endTest();
    return;
  }
  const qIndex = order[idx];
  const q = questions[qIndex];
  if(!q){
    debugLog('Errore: domanda non trovata per indice', qIndex);
    endTest();
    return;
  }

  document.getElementById('questionTitle').textContent = q.text;
  document.getElementById('qInfo').textContent = `${idx+1} / ${order.length}`;
  document.getElementById('feedback').textContent = '';
  document.getElementById('scoreBadge').textContent = `${correctCount}/${totalAnswered}`;

  // Render risposte: manteniamo ordine A-B-C-D (non mischio ora)
  const answersDiv = document.getElementById('answers');
  answersDiv.innerHTML = '';
  q.answers.forEach(a => {
    const btn = document.createElement('button');
    btn.className = 'ans-btn';
    btn.type = 'button';
    btn.textContent = `${a.label}) ${a.text}`;
    btn.dataset.correct = a.correct ? '1' : '0';
    btn.addEventListener('click', () => handleAnswerClick(btn, a));
    answersDiv.appendChild(btn);
  });

  document.getElementById('nextBtn').classList.add('hidden');
  document.getElementById('endBtn').classList.add('hidden');

  debugLog('Mostrata domanda id', q.id, q.text.slice(0,120));
}

/* -------- gestione click risposta -------- */
function handleAnswerClick(button, answerObj){
  // disabilita tutti i bottoni per evitare doppio click
  const btns = Array.from(document.querySelectorAll('.ans-btn'));
  btns.forEach(b => b.disabled = true);

  const correct = answerObj.correct === true;
  totalAnswered++;
  if(correct) correctCount++;

  const fbEl = document.getElementById('feedback');
  if(correct){
    fbEl.className = 'small correct';
    fbEl.textContent = 'CORRETTO ✓';
    debugLog('Risposta corretta', answerObj.label, answerObj.text);
  } else {
    fbEl.className = 'small wrong';
    // mostra quali erano le risposte corrette
    const q = questions[order[idx]];
    const correctAnswers = q.answers.filter(a=>a.correct).map(a=>`${a.label}) ${a.text}`).join('  |  ');
    fbEl.textContent = 'SBAGLIATO ✗  — Risposta corretta: ' + correctAnswers;
    debugLog('Risposta sbagliata', answerObj.label, answerObj.text, 'corrette:', correctAnswers);
  }

  document.getElementById('scoreBadge').textContent = `${correctCount}/${totalAnswered}`;

  // mostra navigazione
  if(idx < order.length - 1){
    document.getElementById('nextBtn').classList.remove('hidden');
    document.getElementById('endBtn').classList.remove('hidden');
  } else {
    document.getElementById('endBtn').classList.remove('hidden');
  }
  document.getElementById('lastAction').textContent = `Ultima azione: risposta ${answerObj.label} (${correct ? 'OK':'KO'})`;
}

/* -------- next / end handlers -------- */
document.getElementById('nextBtn').addEventListener('click', () => {
  idx++;
  showQuestion();
});
document.getElementById('endBtn').addEventListener('click', () => {
  endTest();
});

/* -------- fine test: riepilogo e download risultato -------- */
function endTest(){
  stopTimer();
  const tot = totalAnswered;
  const perc = tot > 0 ? Math.round((correctCount / tot)*100) : 0;
  document.getElementById('quizCard').innerHTML = `
    <h1>Test completato</h1>
    <div class="small">Hai risposto a <strong>${tot}</strong> domande. Corrette: <strong>${correctCount}</strong> (${perc}%).</div>
    <div style="margin-top:12px;" class="row">
      <button id="restart">Riavvia test</button>
      <button id="download" class="secondary">Scarica risultato (JSON)</button>
    </div>
  `;
  debugLog('Test terminato. Tot:', tot, 'Corrette:', correctCount, 'Perc:', perc + '%');

  document.getElementById('restart').addEventListener('click', () => location.reload());
  document.getElementById('download').addEventListener('click', () => {
    const data = { total: tot, correct: correctCount, perc, timestamp: new Date().toISOString() };
    const blob = new Blob([JSON.stringify(data,null,2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'risultato_test.json'; a.click();
    URL.revokeObjectURL(url);
  });
}

/* -------- timer ---------- */
function startTimer(){
  const el = document.getElementById('elapsed');
  if(timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(() => {
    const s = Math.floor((Date.now()-startTime)/1000);
    el.textContent = `Tempo: ${s}s`;
  }, 500);
}
function stopTimer(){ if(timerInterval) clearInterval(timerInterval); }

/* -------- fallback textarea handlers ---------- */
document.getElementById('useManual').addEventListener('click', () => {
  const txt = document.getElementById('manualInput').value;
  if(!txt || txt.trim().length < 10){
    debugLog('manualInput vuoto o troppo corto');
    alert('Incolla il contenuto prima di premere "Usa testo incollato".');
    return;
  }
  debugLog('Usando testo incollato come sorgente domande');
  parseQuestionsFromPlainText(txt);
  if(questions.length === 0){
    debugLog('testo incollato non contiene domande valide');
    alert('Testo non valido: non sono state trovate domande con risposte A/B/C/D.');
    return;
  }
  shuffleOrder();
  idx = 0; correctCount = 0; totalAnswered = 0; startTime = Date.now(); startTimer();
  document.getElementById('fallbackCard').classList.add('hidden');
  document.getElementById('quizCard').classList.remove('hidden');
  showQuestion();
});
document.getElementById('clearManual').addEventListener('click', () => {
  document.getElementById('manualInput').value = '';
  debugLog('manualInput pulito');
});

/* -------- inizializzazione UI -------- */
debugLog('Interfaccia pronta. Pronto a caricare', PDF_FILE);
</script>
</body>
</html>
