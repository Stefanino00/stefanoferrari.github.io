<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Test Distinte.</title>

<!-- Stili migliorati per visibilità -->
<style>
  :root{ --bg:#f6f8fb; --card:#fff; --accent:#0b77f4; --ok:#1e9e4a; --ko:#d32f2f; }
  html,body{ height:100%; margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial; background:var(--bg); color:#111; }
  .wrap{ max-width:980px; margin:20px auto; padding:16px; }
  .card{ background:var(--card); border-radius:10px; box-shadow:0 6px 18px rgba(15,20,30,0.08); padding:16px; margin-bottom:14px; }
  h1{ margin:0 0 6px 0; font-size:18px; }
  .row{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  input[type=password], textarea{ width:100%; padding:10px; border-radius:8px; border:1px solid #ddd; font-size:15px; box-sizing:border-box; }
  button{ background:var(--accent); color:#fff; border:0; padding:10px 14px; border-radius:8px; cursor:pointer; font-weight:600; }
  button.secondary{ background:#f0f0f0; color:#111; }
  .hidden{ display:none; }
  #answers{ margin-top:12px; display:grid; gap:8px; grid-template-columns:1fr; min-height:80px; }
  .ans-btn{ padding:12px; text-align:left; border-radius:8px; border:2px solid #cbd5e1; background:#17ad80; cursor:pointer; font-size:15px; min-height:48px; font-weight:600; }
  .ans-btn[disabled]{ opacity:.6; cursor:not-allowed; }
  #feedback{ margin-top:12px; font-weight:700; }
  pre#debug{ background:#0b1220; color:#d1d5db; padding:12px; border-radius:8px; max-height:220px; overflow:auto; font-size:12px; white-space:pre-wrap; }
  .small { font-size:13px; color:#555; }
  .correct { color:var(--ok); }
  .wrong { color:var(--ko); }
  .meta { display:flex; gap:8px; align-items:center; margin-top:8px; color:#666; font-size:13px; }
  .badge{ background:#eef6ff; color:var(--accent); padding:4px 8px; border-radius:999px; font-weight:700; }
  code{ background:#f3f4f6; padding:2px 6px; border-radius:6px; }
  .qjson{ background:#f8fafc; border:1px dashed #cbd5e1; padding:8px; margin-top:10px; font-size:12px; color:#334155; border-radius:6px; white-space:pre-wrap; }
</style>

<!-- pdf.js -->
<script src="https://unpkg.com/pdfjs-dist@3.8.162/build/pdf.min.js"></script>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Accesso test</h1>
    <div class="small">Inserisci il codice per avviare il test</div>
    <div style="margin-top:10px;" class="row">
      <input id="accessCode" type="password" placeholder="Codice di accesso">
      <button id="btnLogin">Accedi</button>
      <button id="btnDemo" class="secondary">Demo (salta login)</button>
    </div>
    <div id="loginMsg" class="small" style="color:#b00; margin-top:8px;"></div>
  </div>

  <div id="quizCard" class="card hidden">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div>
        <h1 id="questionTitle">Domanda</h1>
        <div class="small" id="qInfo">0 / 0</div>
      </div>
      <div>
        <div class="badge" id="scoreBadge">0/0</div>
      </div>
    </div>

    <div id="answers" style="margin-top:12px;"></div>

    <div id="feedback" class="small"></div>

    <div style="margin-top:12px;" class="row">
      <button id="nextBtn" class="hidden">Prossima domanda</button>
      <button id="endBtn" class="secondary hidden">Termina test</button>
    </div>

    <div class="meta">
      <div id="elapsed">Tempo: 0s</div>
      <div id="lastAction">Ultima azione: -</div>
    </div>

    <!-- Debug JSON visibile della domanda corrente (utile per capire perché UI appare vuota) -->
    <div id="currentQuestionJson" class="qjson hidden"></div>
  </div>

  <div id="fallbackCard" class="card hidden">
    <h1>Fallback: incolla il testo (se il PDF non viene caricato)</h1>
    <div class="small">Ogni domanda inizia con <code>-</code>, risposte A-D; la corretta con <code>*</code> davanti alla lettera.</div>
    <textarea id="manualInput" rows="8" placeholder="Incolla qui il testo..."></textarea>
    <div style="margin-top:10px;" class="row">
      <button id="useManual">Usa testo incollato</button>
      <button id="clearManual" class="secondary">Pulisci</button>
    </div>
  </div>

  <div class="card">
    <h1>Debug (log)</h1>
    <div class="small">Log visibile per capire cosa succede.</div>
    <pre id="debug">Pronto.</pre>
  </div>
</div>

<script>
/* ========== CONFIG ========== */
const ACCESS_CODE = "13112005";
const PDF_FILE = "domandetest3.pdf";

/* stato */
let questions = [];
let order = [];
let idx = 0;
let correctCount = 0;
let totalAnswered = 0;
let startTime = null;
let timerInterval = null;

/* util: rimuove caratteri invisibili e trim */
function sanitizeStr(s){
  if(!s && s!==0) return '';
  return String(s)
    .replace(/\u00A0/g,' ')   // nbsp
    .replace(/[\u200B\u200C\u200D\uFEFF]/g,'') // zero width & BOM
    .replace(/\s+/g,' ')      // collapse multiple spaces
    .trim();
}

/* debug log su UI */
function debugLog(...args){
  const el = document.getElementById('debug');
  const t = new Date().toISOString().slice(11,19);
  el.textContent = `${t} › ${args.map(a=> (typeof a==='object'? JSON.stringify(a,null,2): a)).join(' ')}\n` + el.textContent;
  document.getElementById('lastAction').textContent = 'Ultima azione: ' + (args[0] || '-');
}

/* login */
document.getElementById('btnLogin').addEventListener('click', () => {
  const code = document.getElementById('accessCode').value.trim();
  if(code === ACCESS_CODE){
    document.getElementById('loginMsg').textContent = '';
    startApp();
  } else {
    document.getElementById('loginMsg').textContent = 'Codice errato.';
    debugLog('Login fallito', code);
  }
});
document.getElementById('btnDemo').addEventListener('click', () => { debugLog('Demo: salto login'); startApp(); });

/* start: tenta PDF */
async function startApp(){
  document.getElementById('quizCard').classList.remove('hidden');
  document.getElementById('fallbackCard').classList.add('hidden');
  document.getElementById('debug').textContent = '';
  debugLog('Avvio: provo a caricare PDF', PDF_FILE);

  if(!window.pdfjsLib){
    debugLog('pdfjs non caricato');
    document.getElementById('fallbackCard').classList.remove('hidden');
    return;
  }
  pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@3.8.162/build/pdf.worker.min.js";

  try {
    const resp = await fetch(PDF_FILE);
    if(!resp.ok) throw new Error('PDF non trovato: ' + resp.status);
    const arrayBuffer = await resp.arrayBuffer();
    debugLog('PDF scaricato bytes:', arrayBuffer.byteLength);
    const text = await extractTextFromPDF(arrayBuffer);
    debugLog('Testo estratto (prime 300 ch):', text.slice(0,300));
    parseQuestionsFromPlainText(text);
  } catch(err){
    debugLog('Errore caricamento PDF:', err.message || err);
    document.getElementById('fallbackCard').classList.remove('hidden');
    return;
  }

  if(questions.length === 0){
    debugLog('Parsing non ha trovato domande valide -> mostra fallback');
    document.getElementById('fallbackCard').classList.remove('hidden');
    return;
  }

  shuffleOrder();
  idx = 0; correctCount = 0; totalAnswered = 0;
  startTime = Date.now(); startTimer();
  showQuestion();
}

/* estrai testo con pdf.js */
async function extractTextFromPDF(arrayBuffer){
  const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
  const pdf = await loadingTask.promise;
  debugLog('PDF caricato pagine:', pdf.numPages);
  let fullText = "";
  for(let p=1;p<=pdf.numPages;p++){
    try {
      const page = await pdf.getPage(p);
      const content = await page.getTextContent();
      const strings = content.items.map(i => i.str || '');
      const pageText = strings.join(' ');
      fullText += pageText + '\n\n';
    } catch(e){
      debugLog('Errore estrazione pagina', p, e.message || e);
    }
  }
  return normalizeExtractedText(fullText);
}

/* normalizza: reinserisce break utili e pulisce stringhe invisibili */
function normalizeExtractedText(t){
  let s = String(t || '');
  // rimuovi caratteri invisibili
  s = s.replace(/\u00A0/g,' ').replace(/[\u200B\u200C\u200D\uFEFF]/g,'');
  // collassa spazi multipli ma mantieni linebreaks a loro posto convertendoli in \n
  s = s.replace(/\r\n/g,'\n').replace(/\r/g,'\n');
  // cerca pattern "- " (domanda) e " A " " B "... e assicurati linebreak
  s = s.replace(/\s-\s/g, '\n- ');
  s = s.replace(/\s([A-D])\s+/g, '\n$1 ');
  s = s.replace(/\*(?=[A-D]\s)/g, '\n*');
  // riduci multiple spazi a singolo spazio dentro le linee
  const lines = s.split('\n').map(l => l.replace(/\s+/g,' ').trim()).filter(l=>l.length>0);
  return lines.join('\n');
}

/* parsing robusto */
function parseQuestionsFromPlainText(text){
  questions = [];
  const rawLines = text.split(/\r?\n/).map(l => sanitizeStr(l)).filter(l=>l.length>0);
  debugLog('Righe estratte:', rawLines.length);

  let current = null;
  let idCounter = 0;

  for(let i=0;i<rawLines.length;i++){
    const line = rawLines[i];
    if(line.startsWith('-')){
      current = { text: sanitizeStr(line.replace(/^\-\s*/,'')), answers: [], id: ++idCounter };
      questions.push(current);
      continue;
    }
    // match risposta: accetta "*A" o "A" o "A)" ecc.
    const answerMatch = line.match(/^\*?\s*([A-D])\s*[\)\.\-]?\s*(.*)$/i);
    if(answerMatch){
      const rawLabel = answerMatch[1].toUpperCase();
      let rawText = sanitizeStr(answerMatch[2] || '');
      const leadingStar = /^\*\s*/.test(line);
      const trailingStar = /\*\s*$/.test(rawText);
      if(trailingStar) rawText = rawText.replace(/\*\s*$/,'').trim();
      if(/^\*\s*/.test(rawText)) rawText = rawText.replace(/^\*\s*/,'').trim();
      const correct = leadingStar || trailingStar;
      if(!current){
        current = { text: "(Domanda non trovata — generata automaticamente)", answers: [], id: ++idCounter };
        questions.push(current);
        debugLog('Risposta trovata senza domanda, riga', i+1);
      }
      current.answers.push({ label: rawLabel, text: sanitizeStr(rawText), correct: !!correct });
      continue;
    }
    // linea non match: potrebbe essere continuazione domanda oppure continuazione ultima risposta
    if(current && current.answers.length === 0){
      current.text = sanitizeStr(current.text + ' ' + line);
    } else if(current && current.answers.length > 0){
      const last = current.answers[current.answers.length-1];
      if(last) last.text = sanitizeStr(last.text + ' ' + line);
    } else {
      current = { text: sanitizeStr(line), answers: [], id: ++idCounter };
      questions.push(current);
    }
  }

  const before = questions.length;
  questions = questions.filter(q => q.answers && q.answers.length >= 2);
  debugLog(`Parsing completato. Domande: ${before} -> valide: ${questions.length}`);
  debugLog('Anteprima 5 domande:', questions.slice(0,5).map(q => ({id:q.id, text:q.text.slice(0,120), answers:q.answers})));

  if(questions.length > 0){
    shuffleOrder();
    idx = 0; correctCount = 0; totalAnswered = 0;
    // non partire showQuestion qui: startApp lo fa
  }
}

/* shuffle */
function shuffleArray(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} }
function shuffleOrder(){ order = questions.map((_,i)=>i); shuffleArray(order); debugLog('Ordine mescolato, tot:', order.length); }

/* mostra domanda */
function showQuestion(){
  if(!questions || questions.length===0){ document.getElementById('questionTitle').innerText='Nessuna domanda disponibile'; document.getElementById('answers').innerHTML=''; debugLog('showQuestion: nessuna'); return; }
  if(idx >= order.length){ endTest(); return; }
  const qIndex = order[idx];
  const q = questions[qIndex];
  if(!q){ debugLog('Domanda non trovata indice', qIndex); endTest(); return; }

  // Visual debug: mostra l'oggetto JSON della domanda corrente per troubleshooting
  const jq = document.getElementById('currentQuestionJson');
  jq.classList.remove('hidden');
  jq.innerText = JSON.stringify(q, null, 2);

  document.getElementById('questionTitle').innerText = q.text || '(testo vuoto)';
  document.getElementById('qInfo').innerText = `${idx+1} / ${order.length}`;
  document.getElementById('feedback').innerText = '';
  document.getElementById('scoreBadge').innerText = `${correctCount}/${totalAnswered}`;

  const answersDiv = document.getElementById('answers');
  answersDiv.innerHTML = '';
  // render in ordine A,B,C,D (se presenti)
  q.answers.forEach(a => {
      const btn = document.createElement('button');
      btn.className = 'ans-btn';
      btn.type = 'button';
      
      // Pulizia testo per PDF
      let cleanText = sanitizeStr(a.text);
      btn.textContent = `${a.label}) ${cleanText}`;
      
      btn.dataset.correct = a.correct ? '1' : '0';
      
      // Stile che forza il testo visibile anche se lungo
      btn.style.whiteSpace = 'pre-wrap';
      btn.style.wordBreak = 'break-word';
      
      btn.addEventListener('click', () => handleAnswerClick(btn, a));
      answersDiv.appendChild(btn);
  });


  document.getElementById('nextBtn').classList.add('hidden');
  document.getElementById('endBtn').classList.add('hidden');

  debugLog('Mostrata domanda id', q.id, 'testo (prime 80):', q.text.slice(0,80));
}

/* click risposta */
function handleAnswerClick(button, answerObj){
  const btns = Array.from(document.querySelectorAll('.ans-btn'));
  btns.forEach(b => b.disabled = true);

  const correct = answerObj.correct === true;
  totalAnswered++; if(correct) correctCount++;

  const fbEl = document.getElementById('feedback');
  if(correct){
    fbEl.className = 'small correct';
    fbEl.innerText = 'CORRETTO ✓';
    debugLog('Risposta corretta', answerObj.label, answerObj.text);
  } else {
    fbEl.className = 'small wrong';
    const q = questions[order[idx]];
    const correctAnswers = q.answers.filter(a=>a.correct).map(a=>`${a.label}) ${a.text}`).join('  |  ');
    fbEl.innerText = 'SBAGLIATO ✗  — Risposta corretta: ' + correctAnswers;
    debugLog('Risposta sbagliata', answerObj.label, answerObj.text, 'corrette:', correctAnswers);
  }

  document.getElementById('scoreBadge').innerText = `${correctCount}/${totalAnswered}`;
  if(idx < order.length -1){ document.getElementById('nextBtn').classList.remove('hidden'); document.getElementById('endBtn').classList.remove('hidden'); }
  else { document.getElementById('endBtn').classList.remove('hidden'); }
  document.getElementById('lastAction').innerText = `Ultima azione: risposta ${answerObj.label} (${correct ? 'OK':'KO'})`;
}

/* next / end */
document.getElementById('nextBtn').addEventListener('click', () => { idx++; showQuestion(); });
document.getElementById('endBtn').addEventListener('click', () => endTest());

/* end test */
function endTest(){
  stopTimer();
  const tot = totalAnswered;
  const perc = tot>0 ? Math.round((correctCount/tot)*100) : 0;
  document.getElementById('quizCard').innerHTML = `
    <h1>Test completato</h1>
    <div class="small">Hai risposto a <strong>${tot}</strong> domande. Corrette: <strong>${correctCount}</strong> (${perc}%).</div>
    <div style="margin-top:12px;" class="row">
      <button id="restart">Riavvia test</button>
      <button id="download" class="secondary">Scarica risultato (JSON)</button>
    </div>
  `;
  debugLog('Test terminato. Tot:', tot, 'Corrette:', correctCount, 'Perc:', perc + '%');
  document.getElementById('restart').addEventListener('click', () => location.reload());
  document.getElementById('download').addEventListener('click', () => {
    const data = { total: tot, correct: correctCount, perc, timestamp: new Date().toISOString() };
    const blob = new Blob([JSON.stringify(data,null,2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'risultato_test.json'; a.click(); URL.revokeObjectURL(url);
  });
}

/* timer */
function startTimer(){ const el = document.getElementById('elapsed'); if(timerInterval) clearInterval(timerInterval); timerInterval = setInterval(()=>{ const s=Math.floor((Date.now()-startTime)/1000); el.innerText = `Tempo: ${s}s`; },500); }
function stopTimer(){ if(timerInterval) clearInterval(timerInterval); }

/* fallback manual */
document.getElementById('useManual').addEventListener('click', () => {
  const txt = document.getElementById('manualInput').value;
  if(!txt || txt.trim().length<10){ debugLog('manualInput vuoto o corto'); alert('Incolla il contenuto prima di premere "Usa testo incollato".'); return; }
  debugLog('Usando testo incollato come sorgente domande');
  parseQuestionsFromPlainText(txt);
  if(questions.length === 0){ debugLog('Testo incollato non valido'); alert('Testo non valido: nessuna domanda trovata.'); return; }
  shuffleOrder(); idx=0; correctCount=0; totalAnswered=0; startTime=Date.now(); startTimer();
  document.getElementById('fallbackCard').classList.add('hidden');
  document.getElementById('quizCard').classList.remove('hidden');
  showQuestion();
});
document.getElementById('clearManual').addEventListener('click', () => { document.getElementById('manualInput').value=''; debugLog('manualInput pulito'); });

debugLog('Interfaccia pronta. Pronto a caricare', PDF_FILE);
</script>
</body>
</html>
